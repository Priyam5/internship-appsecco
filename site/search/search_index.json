{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Project Title: Cloud Native Implementation of DevSecOps Concepts Author: Priyam Singh Mentor: Akash Mahajan , Sunesh Govindaraj , Ayush Priya The report documents the tasks I am working and practicing as a part of my internship at Appsecco on Cloud Native implementation of DevSecOps concepts for an application as well as the issues I am facing while working, and how I resolved them.","title":"Introduction"},{"location":"#introduction","text":"Project Title: Cloud Native Implementation of DevSecOps Concepts Author: Priyam Singh Mentor: Akash Mahajan , Sunesh Govindaraj , Ayush Priya The report documents the tasks I am working and practicing as a part of my internship at Appsecco on Cloud Native implementation of DevSecOps concepts for an application as well as the issues I am facing while working, and how I resolved them.","title":"Introduction"},{"location":"code-quality-analysis/","text":"Code Quality Analysis Objective This section aims to perform a linting check on the source code of angular-realworld-example-app and generate a report to provide a solution to the 2nd point of the problem statement under Task 1. Code Linting Linting is the automated checking of source code for programmatic and stylistic errors. This is done by using a linting tool. A lint tool is a basic static code analyzer. Linting is important to reduce errors and improve the overall quality of code. Using lint tools can help accelerate development and reduce costs by finding errors earlier. Linting tools are language-specific and thus, the tool that can be used depends on the application being tested. Nowadays, we have different linters, which provide many types of checks like syntax errors, code standards adherence, potential problems, security checks. Linting tools for angular-realworld-example-app Angular-realworld-example-app is a JavaScript application and hence, I used jshint as the linter. I primarily chose jshint as it is available as a command-line utility and hence, I used this documentation for using jshint. Writing YAML file in GitHub Action I created a new file linting-tool.yml in the .github/workflows. The YAML file is this: name: \"linting-tool-scan\" on: push: branches: [master] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: install dependencies run: | sudo apt install npm sudo npm install --package-lock npm audit fix - name: Installing JSHint run: | sudo npm install -g jshint - name: Run scan with JSHint run: | sudo jshint --exclude=\"node_modules/\" --reporter=unix . node_modules It excludes the node_modules/ directory and also exclude any files which do not have a .js or .ejs extension. --reporter By using this option, I can change the output format. I selected unix , as it will become easier to count the rows and words. There are other options like checkstyle , the output will be in an xml format.","title":"Code Quality Analysis"},{"location":"code-quality-analysis/#code-quality-analysis","text":"","title":"Code Quality Analysis"},{"location":"code-quality-analysis/#objective","text":"This section aims to perform a linting check on the source code of angular-realworld-example-app and generate a report to provide a solution to the 2nd point of the problem statement under Task 1.","title":"Objective"},{"location":"code-quality-analysis/#code-linting","text":"Linting is the automated checking of source code for programmatic and stylistic errors. This is done by using a linting tool. A lint tool is a basic static code analyzer. Linting is important to reduce errors and improve the overall quality of code. Using lint tools can help accelerate development and reduce costs by finding errors earlier. Linting tools are language-specific and thus, the tool that can be used depends on the application being tested. Nowadays, we have different linters, which provide many types of checks like syntax errors, code standards adherence, potential problems, security checks.","title":"Code Linting"},{"location":"code-quality-analysis/#linting-tools-for-angular-realworld-example-app","text":"Angular-realworld-example-app is a JavaScript application and hence, I used jshint as the linter. I primarily chose jshint as it is available as a command-line utility and hence, I used this documentation for using jshint.","title":"Linting tools for angular-realworld-example-app"},{"location":"code-quality-analysis/#writing-yaml-file-in-github-action","text":"I created a new file linting-tool.yml in the .github/workflows. The YAML file is this: name: \"linting-tool-scan\" on: push: branches: [master] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: install dependencies run: | sudo apt install npm sudo npm install --package-lock npm audit fix - name: Installing JSHint run: | sudo npm install -g jshint - name: Run scan with JSHint run: | sudo jshint --exclude=\"node_modules/\" --reporter=unix . node_modules It excludes the node_modules/ directory and also exclude any files which do not have a .js or .ejs extension. --reporter By using this option, I can change the output format. I selected unix , as it will become easier to count the rows and words. There are other options like checkstyle , the output will be in an xml format.","title":"Writing YAML file in GitHub Action"},{"location":"contents/","text":"Table of contents The following is the report/documentation for the Problem Statement stated in next section. The contents of the report are: Introduction Contents Problem Statement SAST through GitHub Action Code Quality Analysis Software Bill of Materials","title":"Contents"},{"location":"contents/#table-of-contents","text":"The following is the report/documentation for the Problem Statement stated in next section. The contents of the report are: Introduction Contents Problem Statement SAST through GitHub Action Code Quality Analysis Software Bill of Materials","title":"Table of contents"},{"location":"github-action/","text":"SAST through Github Action Objective This section aims to perform SAST for angular-realworld-example-app and generate a report to provide a solution to the 1st point of the problem statement under Task 1. Github Action GitHub Actions make it easy to automate all software workflows. Github Actions let us build, test, and deploy our code right from GitHub. We can also assign code reviews, manage branches, and triage issues the way we want with actions. GitHub Actions are designed to help in building robust and dynamic automation's. Whether we want to build a container, deploy a web service, or automate welcoming a new user to our open-source project \u2014 there\u2019s an automated action for that. Creating Workflow I followed this official link for creating the first workflow . On GitHub, I forked angular-realworld-example-app and I created a new file in the .github/workflows . I made the following YAML contents into the sast-scan.yml file. For knowing the syntax of Github action I followed this official link. name: \"sast-scan\" on: push: branches: [master] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: install dependencies run: | sudo apt install npm sudo npm install --package-lock npm audit fix first - name: OWASP Dependency Check run: | wget https://github.com/jeremylong/DependencyCheck/releases/download/v6.0.2/dependency-check-6.0.2-release.zip unzip dependency-check-6.0.2-release.zip - name: Run scan with ODC run: | dependency-check/bin/dependency-check.sh --project \"angular-realworld-example-app\" --scan . To run workflow, I scrolled to the bottom of the page and select Commit directly to the main branch. Then, to create a pull request, click Propose new file . Committing the workflow file in repository triggers the push event and runs workflow. Viewing workflow results Under repository name, click Actions . In the left sidebar, click the workflow to see. From the list of workflow runs, click the name of the run to see. In the left sidebar, click the Lint code base job. Expand the Run sast-scan step to view the results.","title":"SAST Github Action"},{"location":"github-action/#sast-through-github-action","text":"","title":"SAST through Github Action"},{"location":"github-action/#objective","text":"This section aims to perform SAST for angular-realworld-example-app and generate a report to provide a solution to the 1st point of the problem statement under Task 1.","title":"Objective"},{"location":"github-action/#github-action","text":"GitHub Actions make it easy to automate all software workflows. Github Actions let us build, test, and deploy our code right from GitHub. We can also assign code reviews, manage branches, and triage issues the way we want with actions. GitHub Actions are designed to help in building robust and dynamic automation's. Whether we want to build a container, deploy a web service, or automate welcoming a new user to our open-source project \u2014 there\u2019s an automated action for that.","title":"Github Action"},{"location":"github-action/#creating-workflow","text":"I followed this official link for creating the first workflow . On GitHub, I forked angular-realworld-example-app and I created a new file in the .github/workflows . I made the following YAML contents into the sast-scan.yml file. For knowing the syntax of Github action I followed this official link. name: \"sast-scan\" on: push: branches: [master] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: install dependencies run: | sudo apt install npm sudo npm install --package-lock npm audit fix first - name: OWASP Dependency Check run: | wget https://github.com/jeremylong/DependencyCheck/releases/download/v6.0.2/dependency-check-6.0.2-release.zip unzip dependency-check-6.0.2-release.zip - name: Run scan with ODC run: | dependency-check/bin/dependency-check.sh --project \"angular-realworld-example-app\" --scan . To run workflow, I scrolled to the bottom of the page and select Commit directly to the main branch. Then, to create a pull request, click Propose new file . Committing the workflow file in repository triggers the push event and runs workflow.","title":"Creating Workflow"},{"location":"github-action/#viewing-workflow-results","text":"Under repository name, click Actions . In the left sidebar, click the workflow to see. From the list of workflow runs, click the name of the run to see. In the left sidebar, click the Lint code base job. Expand the Run sast-scan step to view the results.","title":"Viewing workflow results"},{"location":"problem-statement/","text":"Problem Statement Task 1 Performing SAST on the application through GitHub Actions and generate the report. Performing source Code Quality Analysis for linting errors to improve code quality and generate quality report. Generating Software Bill of Materials of application for all dependencies.","title":"Problem Statement"},{"location":"problem-statement/#problem-statement","text":"","title":"Problem Statement"},{"location":"problem-statement/#task-1","text":"Performing SAST on the application through GitHub Actions and generate the report. Performing source Code Quality Analysis for linting errors to improve code quality and generate quality report. Generating Software Bill of Materials of application for all dependencies.","title":"Task 1"},{"location":"sbom/","text":"Software Bill of Materials Objective This section aims to generate a Software Bill of Materials for angular-realworld-example-app and generate a report to provide a solution to the 3rd point of the problem statement under Task 1. Software Bill of Materials A software bill of materials is a list of all the open source and third-party components present in a codebase. A software BOM also lists the licenses that govern those components, the versions of the components used in the codebase, and their patch status. With a software bill of materials, we can respond quickly to the security, license, and operational risks that come with open source use. CycloneDX CycloneDX is a tool of lightweight software bill of materials (SBOM) specification designed for use in application security contexts and supply chain component analysis. Angular-realworld-example-app, like most other applications, is built with various dependencies. So I used CycloneDX to generate the SBOM for Angular-realworld-example-app. CycloneDX is available to use a node.js package that can generate SBOMs but also comes in a variety of implementations that can be found here to serve projects which use different stacks such as Auditjs, Python, Maven, .NET, PHP, etc. Generating SBOM through YAML file in GitHub Action I created a new file sbom.yml in the .github/workflows. I used this plugin CycloneDX Node.js Generate SBOM The YAML file is this for generating the SBOM is: name: \"sbom-scan\" on: push: branches: [master] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: install dependencies run: | sudo apt install npm sudo npm install --package-lock npm audit fix - name: Installing SBOM run: | sudo npm install -g @cyclonedx/bom - name: CycloneDX Node.js Generate SBOM uses: CycloneDX/gh-node-module-generatebom@v1.0.0","title":"Software Bill of Materials"},{"location":"sbom/#software-bill-of-materials","text":"","title":"Software Bill of Materials"},{"location":"sbom/#objective","text":"This section aims to generate a Software Bill of Materials for angular-realworld-example-app and generate a report to provide a solution to the 3rd point of the problem statement under Task 1.","title":"Objective"},{"location":"sbom/#software-bill-of-materials_1","text":"A software bill of materials is a list of all the open source and third-party components present in a codebase. A software BOM also lists the licenses that govern those components, the versions of the components used in the codebase, and their patch status. With a software bill of materials, we can respond quickly to the security, license, and operational risks that come with open source use.","title":"Software Bill of Materials"},{"location":"sbom/#cyclonedx","text":"CycloneDX is a tool of lightweight software bill of materials (SBOM) specification designed for use in application security contexts and supply chain component analysis. Angular-realworld-example-app, like most other applications, is built with various dependencies. So I used CycloneDX to generate the SBOM for Angular-realworld-example-app. CycloneDX is available to use a node.js package that can generate SBOMs but also comes in a variety of implementations that can be found here to serve projects which use different stacks such as Auditjs, Python, Maven, .NET, PHP, etc.","title":"CycloneDX"},{"location":"sbom/#generating-sbom-through-yaml-file-in-github-action","text":"I created a new file sbom.yml in the .github/workflows. I used this plugin CycloneDX Node.js Generate SBOM The YAML file is this for generating the SBOM is: name: \"sbom-scan\" on: push: branches: [master] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: install dependencies run: | sudo apt install npm sudo npm install --package-lock npm audit fix - name: Installing SBOM run: | sudo npm install -g @cyclonedx/bom - name: CycloneDX Node.js Generate SBOM uses: CycloneDX/gh-node-module-generatebom@v1.0.0","title":"Generating SBOM through YAML file in GitHub Action"}]}